org 100h

[map all pacman.map]

%define SCREEN_WIDTH 320
%define SCREEN_HEIGHT 200


%define SPRITEW 8
%define SPRITEH 8
section .data

xPosBlinky dw 0
xPosInky dw 0
xPosClyde dw 0
xPosPinky dw 0

yPosBlinky dw 0
yPosInky dw 0
yPosClyde dw 0
yPosPinky dw 0

xVelocity dw 0

spritew dw 8
spriteh dw 8

old_XPOSBlinky dw 0
old_XPOSInky dw 0
old_XPOSClyde dw 0
old_XPOSPinky dw 0

old_YPOSBlinky dw 0
old_YPOSInky dw 0
old_YPOSClyde dw 0
old_YPOSPinky dw 0

currentSpriteBlinky dd blinky_right_1
actualKeystroke dw 4Dh

; ====================
;   blinky sprites
; ====================
;   blinky look up
; ====================
blinky_up_1     db 0xFF, 0xFF, 0x28, 0x28, 0x28, 0x28, 0x04, 0xFF
                db 0xFF, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x0F, 0x00, 0x28, 0x00, 0x0F, 0x28, 0x04
                db 0x28, 0x0F, 0x0F, 0x28, 0x0F, 0x0F, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0xFF, 0x28, 0xFF, 0x28, 0xFF, 0x28, 0x04

blinky_up_2     db 0xFF, 0xFF, 0x28, 0x28, 0x28, 0x28, 0x04, 0xFF
                db 0xFF, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x0F, 0x00, 0x28, 0x00, 0x0F, 0x28, 0x04
                db 0x28, 0x0F, 0x0F, 0x28, 0x0F, 0x0F, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0xFF, 0x28, 0xFF, 0x28, 0xFF, 0x04

blinky_up_3     db 0xFF, 0xFF, 0x28, 0x28, 0x28, 0x28, 0x04, 0xFF
                db 0xFF, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x0F, 0x00, 0x28, 0x00, 0x0F, 0x28, 0x04
                db 0x28, 0x0F, 0x0F, 0x28, 0x0F, 0x0F, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0xFF, 0x28, 0xFF, 0x28, 0xFF, 0x28, 0x28, 0x04
; ====================
;   blinky look left
; ====================
blinky_left_1   db 0xFF, 0xFF, 0x28, 0x28, 0x28, 0x28, 0x04, 0xFF
                db 0xFF, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x00, 0x0F, 0x28, 0x00, 0x0F, 0x28, 0x04
                db 0x28, 0x00, 0x0F, 0x28, 0x00, 0x0F, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0xFF, 0x28, 0xFF, 0x28, 0xFF, 0x28, 0x04

blinky_left_2   db 0xFF, 0xFF, 0x28, 0x28, 0x28, 0x28, 0x04, 0xFF
                db 0xFF, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x00, 0x0F, 0x28, 0x00, 0x0F, 0x28, 0x04
                db 0x28, 0x00, 0x0F, 0x28, 0x00, 0x0F, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0xFF, 0x28, 0xFF, 0x28, 0xFF, 0x04

blinky_left_3   db 0xFF, 0xFF, 0x28, 0x28, 0x28, 0x28, 0x04, 0xFF
                db 0xFF, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x00, 0x0F, 0x28, 0x00, 0x0F, 0x28, 0x04
                db 0x28, 0x00, 0x0F, 0x28, 0x00, 0x0F, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0xFF, 0x28, 0xFF, 0x28, 0xFF, 0x28, 0x28, 0x04
; ====================
;   blinky look right
; ====================
blinky_right_1  db 0xFF, 0x04, 0x28, 0x28, 0x28, 0x28, 0x28, 0xFF
                db 0x04, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28
                db 0x04, 0x28, 0x0F, 0xFF, 0x28, 0x0F, 0xFF, 0x28
                db 0x04, 0x28, 0x0F, 0xFF, 0x28, 0x0F, 0xFF, 0x28
                db 0x04, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28
                db 0x04, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28
                db 0x04, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28
                db 0x04, 0x28, 0xFF, 0x28, 0xFF, 0x28, 0xFF, 0x28

blinky_right_2  db 0xFF, 0x04, 0x28, 0x28, 0x28, 0x28, 0x28, 0xFF
                db 0x04, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28
                db 0x04, 0x28, 0x0F, 0xFF, 0x28, 0x0F, 0xFF, 0x28
                db 0x04, 0x28, 0x0F, 0xFF, 0x28, 0x0F, 0xFF, 0x28
                db 0x04, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28
                db 0x04, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28
                db 0x04, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28
                db 0x04, 0x28, 0x28, 0xFF, 0x28, 0xFF, 0x28, 0xFF

blinky_right_3  db 0xFF, 0x04, 0x28, 0x28, 0x28, 0x28, 0x28, 0xFF
                db 0x04, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28
                db 0x04, 0x28, 0x0F, 0xFF, 0x28, 0x0F, 0xFF, 0x28
                db 0x04, 0x28, 0x0F, 0xFF, 0x28, 0x0F, 0xFF, 0x28
                db 0x04, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28
                db 0x04, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28
                db 0x04, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28
                db 0x04, 0xFF, 0x28, 0xFF, 0x28, 0xFF, 0x28, 0x28
; ====================
;   BLINKY LOOK DOWN
; ====================
blinky_down_1   db 0xFF, 0xFF, 0x28, 0x28, 0x28, 0x28, 0x04, 0xFF
                db 0xFF, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x0F, 0x0F, 0x28, 0x0F, 0x0F, 0x28, 0x04
                db 0x28, 0x0F, 0x00, 0x28, 0x00, 0x0F, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0xFF, 0x28, 0xFF, 0x28, 0xFF, 0x28, 0x04

blinky_down_2   db 0xFF, 0xFF, 0x28, 0x28, 0x28, 0x28, 0x04, 0xFF
                db 0xFF, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x0F, 0x0F, 0x28, 0x0F, 0x0F, 0x28, 0x04
                db 0x28, 0x0F, 0x00, 0x28, 0x00, 0x0F, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0xFF, 0x28, 0xFF, 0x28, 0xFF, 0x04

blinky_down_3   db 0xFF, 0xFF, 0x28, 0x28, 0x28, 0x28, 0x04, 0xFF
                db 0xFF, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x0F, 0x0F, 0x28, 0x0F, 0x0F, 0x28, 0x04
                db 0x28, 0x0F, 0x00, 0x28, 0x00, 0x0F, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x04
                db 0xFF, 0x28, 0xFF, 0x28, 0xFF, 0x28, 0x28, 0x04

section .bss
keyPressed resb 1  ; Réserve un byte pour l'état de la touche
section .text
start:
    ; Initialisation du mode vidéo
    mov ah, 00h
    mov al, 13h
    int 10h
    ; Boucle principale du jeu

       
    
    gameloop:
    call clearSprite  ; Clear the old sprite before drawing a new one
    call draw_sprite
    call read_character_key_was_pressed



    ; Delay to slow down the animation
    mov cx, 64000
    waitloop:
        loop waitloop
    jmp gameloop
    ; Fin du jeu, retour au mode texte
    mov ax, 03h
    int 10h
    mov ax, 4C00h
    int 21h


clearScreen:
    mov bx, 0xA000
    mov es, bx
    mov di, 0
    mov cx, 200*320
    rep stosb
    ret 

; Fonction pour lire la touche pressée
read_character_key_was_pressed:
    mov ah, 01h        ; Check if a key has been pressed (non-blocking)
    int 16h
    jz continue_movement ; If no key pressed, continue current movement

    ; Read the keystroke
    mov ah, 00h
    int 16h
    mov [actualKeystroke], ah  ; Store the new direction

clearSprite:
    ; Set up the graphics segment
    mov ax, 0A000h
    mov es, ax

    ; Calculate the screen offset for the old position of the sprite
    mov ax, [old_YPOSBlinky]     ; Get the old Y position
    imul ax, 320           ; Multiply Y position by screen width to get the offset
    add ax, [old_XPOSBlinky]     ; Add the old X position to the offset
    mov di, ax             ; DI = starting address for erasure

    ; Define the height and width of the sprite
    mov cx, SPRITEH        ; Sprite height
.clear_line:
    push cx                ; Save CX as it is modified by the loop
    mov cx, SPRITEW        ; Sprite width for a single line
    mov al, 0              ; Background color (usually black for Pac-Man)
    rep stosb              ; Clear pixels with background color
    pop cx                 ; Restore CX for the next line
    add di, 320 - SPRITEW  ; Adjust DI to the start of the next line
    loop .clear_line       ; Repeat for each line of the sprite
    ret
    

move_right:
    mov word [actualKeystroke], 4Dh
    call blinky_right
    mov bx, [xPosBlinky]
    add bx, 1
    cmp bx, SCREEN_WIDTH - SPRITEW 
    jae .skip_move_right
    mov [xPosBlinky], bx
.skip_move_right:
    ret
move_left:
    mov word [actualKeystroke], 4Bh
    call blinky_left
    mov bx, [xPosBlinky]
    sub bx, 1
    cmp bx, 0
    jbe .skip_move_left
    mov [xPosBlinky], bx
.skip_move_left:
    ret

move_up:
    mov word [actualKeystroke], 48h
    call blinky_up
    mov bx, [yPosBlinky]
    sub bx, 1
    cmp bx, 0
    jbe .skip_move_up
    mov [yPosBlinky], bx
.skip_move_up:
    ret

move_down:
    call blinky_down
    mov bx, [yPosBlinky]
    add bx, 1
    cmp bx, SCREEN_HEIGHT - SPRITEH 
    jae .skip_move_down
    mov [yPosBlinky], bx
.skip_move_down:
    ret

continue_movement:
    mov al, [actualKeystroke]
    cmp al, 4Dh
    je .move_right
    cmp al, 4Bh
    je .move_left
    cmp al, 48h
    je .move_up
    cmp al, 50h
    je .move_down
    ret
    .move_right:
        call move_right
        ret
    .move_left:
        call move_left
        ret
    .move_up:
        call move_up
        ret
    .move_down:
        call move_down
        ret
    ret

blinky_right:
    cmp word [currentSpriteBlinky], blinky_right_1
    je .blinkyRightSemiOpen
    cmp word [currentSpriteBlinky], blinky_right_2
    je .blinkyRightOpen
    cmp word [currentSpriteBlinky], blinky_right_3
    je .blinkyRightClose

    .blinkyRightOpen:
       mov word [currentSpriteBlinky], blinky_right_1
       mov si, [currentSpriteBlinky]
       ret
    .blinkyRightSemiOpen:
        mov word [currentSpriteBlinky], blinky_right_2
        mov si, [currentSpriteBlinky]
        ret
    .blinkyRightClose:
        mov word [currentSpriteBlinky], blinky_right_3
        mov si, [currentSpriteBlinky]
        ret

blinky_left:
    cmp word [currentSpriteBlinky], blinky_left_1
    je .blinkyLeftSemiOpen
    cmp word [currentSpriteBlinky], blinky_left_2
    je .blinkyLeftClose
    cmp word [currentSpriteBlinky], blinky_left_3
    je .blinkyLeftOpen

    .blinkyLeftOpen:
       mov word [currentSpriteBlinky], blinky_left_1
       mov si, [currentSpriteBlinky]
       ret
    .blinkyLeftSemiOpen:
        mov word [currentSpriteBlinky], blinky_left_2
        mov si, [currentSpriteBlinky]
        ret
    .blinkyLeftClose:
        mov word [currentSpriteBlinky], blinky_left_3
        mov si, [currentSpriteBlinky]
        ret

blinky_up:
    cmp word [currentSpriteBlinky], blinky_up_1
    je .blinkyUpSemiOpen
    cmp word [currentSpriteBlinky], blinky_up_2
    je .blinkyUpClose
    cmp word [currentSpriteBlinky], blinky_up_3
    je .blinkyUpOpen

    .blinkyUpOpen:
       mov word [currentSpriteBlinky], blinky_up_1
       mov si, [currentSpriteBlinky]
       ret
    .blinkyUpSemiOpen:
        mov word [currentSpriteBlinky], blinky_up_2
        mov si, [currentSpriteBlinky]
        ret
    .blinkyUpClose:
        mov word [currentSpriteBlinky], blinky_up_3
        mov si, [currentSpriteBlinky]
        ret
    
blinky_down:
    cmp word [currentSpriteBlinky], blinky_down_1
    je .blinkyDownSemiOpen
    cmp word [currentSpriteBlinky], blinky_down_2
    je .blinkyDownClose
    cmp word [currentSpriteBlinky], blinky_down_3
    je .blinkyDownOpen

    .blinkyDownOpen:
       mov word [currentSpriteBlinky], blinky_down_1
       mov si, [currentSpriteBlinky]
       ret
    .blinkyDownSemiOpen:
        mov word [currentSpriteBlinky], blinky_down_2
        mov si, [currentSpriteBlinky]
        ret
    .blinkyDownClose:
        mov word [currentSpriteBlinky], blinky_down_3
        mov si, [currentSpriteBlinky]
        ret

; Fonction pour effacer l'écran
draw_sprite:
    mov si, [currentSpriteBlinky]
    ; Avant de dessiner le sprite, sauvegardez la position actuelle
    mov ax, [xPosBlinky]
    mov [old_XPOSBlinky], ax  ; Sauvegarde l'ancienne position X
    mov ax, [yPosBlinky]
    mov [old_YPOSBlinky], ax  ; Sauvegarde l'ancienne position Y
    ; Réinitialise le segment graphique
    mov ax, 0A000h
    mov es, ax
    ; Calcule l'adresse à l'écran où le sprite sera dessiné
    mov ax, [yPosBlinky]
    imul ax, 320       ; Multiplie yPos par la largeur de l'écran pour obtenir l'offset
    add ax, [xPosBlinky]     ; Ajoute xPos à l'offset
    mov di, ax         ; DI = adresse de départ pour le dessin
    ; Obtient l'adresse du sprite à dessiner
    ; Définit la hauteur du sprite
    mov cx, SPRITEH
.draw_line:
    ; Sauvegarde CX car il est modifié par REP MOVSB
    push cx
    ; Définit la largeur du sprite pour la ligne actuelle
    mov cx, SPRITEW
    rep movsb  ; Dessine la ligne du sprite à l'écran
    ; Restaure CX pour la prochaine ligne
    pop cx
    ; Ajuste DI pour la ligne suivante en prenant en compte l'offset de la largeur de l'écran
    add di, 320 - SPRITEW
    loop .draw_line  ; Répète le dessin pour chaque ligne du sprite
    ret
